

What This Minimal PHP Backend Will Do
✅ Set up a basic PHP server (No frameworks).
✅ Handle WebSocket connections for real-time updates.
✅ Provide a simple API (REST-like) for game state management.
✅ Use Docker to run everything in a clean container.



ft_transcendence/
│── backend/              
│   ├── public/            # Publicly accessible files (ex: API entry point)
│   │   ├── index.php      # API entry point
│   │   ├── api.php        # Simple REST API (Game state, reset, etc.)
│   ├── src/              
│   │   ├── Database.php   # Database connection (future-proof)
│   │   ├── Game.php       # Game logic
│   ├── websocket.php      # WebSocket server for real-time game updates
│
│── docker/                
│   ├── Dockerfile.php      # Backend container setup
│
│── docker-compose.yml      # Defines services (backend, database, etc.)
│── Makefile                # Commands for running Docker

//

Minimal index.php (Entry Point)
This file serves as the main API entry point.

📍 File: backend/public/index.php

<?php
// Serve static files (HTML, JS, etc.)
if (php_sapi_name() === 'cli-server') {
    $url = parse_url($_SERVER['REQUEST_URI']);
    $file = __DIR__ . $url['path'];
    if (is_file($file)) return false;
}

// Load API
require_once 'api.php';
?>

What This Does:

If PHP's built-in web server is used (php -S), it serves static files directly.
Otherwise, it routes everything to api.php.

//

Minimal api.php (Game API)
This handles basic game logic, such as retrieving and resetting the game state.

📍 File: backend/public/api.php

<?php
header("Content-Type: application/json");

// Simulated Game State (normally stored in a database)
$gameState = [
    "player1_score" => 0,
    "player2_score" => 0,
    "ball_position" => ["x" => 150, "y" => 100]
];

// Handle API Requests
if ($_SERVER['REQUEST_METHOD'] === 'GET') {
    echo json_encode($gameState);
} elseif ($_SERVER['REQUEST_METHOD'] === 'POST') {
    $input = json_decode(file_get_contents("php://input"), true);

    if (isset($input["reset"])) {
        $gameState["player1_score"] = 0;
        $gameState["player2_score"] = 0;
        $gameState["ball_position"] = ["x" => 150, "y" => 100];
    }

    echo json_encode(["status" => "success", "game" => $gameState]);
} else {
    echo json_encode(["error" => "Invalid request"]);
}
?>

 What This Does:

GET /api.php → Returns the current game state.
POST /api.php → Resets the game if {"reset": true} is sent.

//

Minimal websocket.php (WebSocket Server)
Handles real-time communication between players.

📍 File: backend/websocket.php

<?php
error_reporting(E_ALL);
set_time_limit(0);
ob_implicit_flush();

$host = "0.0.0.0";
$port = 8081;

$serverSocket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP);
socket_set_option($serverSocket, SOL_SOCKET, SO_REUSEADDR, 1);
socket_bind($serverSocket, $host, $port);
socket_listen($serverSocket);

$clients = [];

echo "WebSocket Server started on ws://$host:$port\n";

while (true) {
    $changed = $clients;
    $changed[] = $serverSocket;
    socket_select($changed, $write, $except, 0, 10);

    if (in_array($serverSocket, $changed)) {
        $clientSocket = socket_accept($serverSocket);
        $clients[] = $clientSocket;
        unset($changed[array_search($serverSocket, $changed)]);
    }

    foreach ($changed as $client) {
        $data = @socket_read($client, 1024);
        if ($data === false) {
            unset($clients[array_search($client, $clients)]);
            continue;
        }

        broadcast(["message" => "New WebSocket message"], $clients);
    }
}

function broadcast($message, $clients) {
    $msg = json_encode($message);
    foreach ($clients as $client) {
        socket_write($client, $msg . "\n");
    }
}
?>

What This Does:

Starts a WebSocket server on ws://localhost:8081.
Accepts new clients and broadcasts messages to all connected clients.

//

 Minimal Dockerfile.php (Backend Container)
📍 File: docker/Dockerfile.php

FROM php:8.0-fpm

WORKDIR /var/www/html

# Copy backend files
COPY ../backend /var/www/html

# Install PHP sockets extension (needed for WebSockets)
RUN docker-php-ext-install sockets

# Expose PHP-FPM & WebSocket ports
EXPOSE 9000 8081

CMD ["php-fpm"]

What This Does:

Uses PHP 8.0 with FastCGI (FPM).
Copies the backend files.
Installs the PHP sockets extension (for WebSockets).
Runs PHP-FPM to handle web requests.

//

 Minimal docker-compose.yml
📍 File: docker-compose.yml

version: "3.8"

services:
  backend:
    build:
      context: .
      dockerfile: docker/Dockerfile.php
    container_name: php_backend
    restart: always
    volumes:
      - ./backend:/var/www/html
    ports:
      - "9000:9000"
      - "8081:8081"

What This Does:

Defines the PHP backend container.
Exposes:
Port 9000 for PHP processing.
Port 8081 for WebSockets.

//

Minimal Makefile (Run Everything)
📍 File: Makefile

run:
	docker-compose up --build -d

stop:
	docker-compose down

logs:
	docker-compose logs -f

What This Does:

make run → Builds & runs everything.
make stop → Stops containers.
make logs → Shows container logs.

//

// Run the backend
make run

// test API
curl http://localhost:9000/index.php

// Test websocket

Open browser console (F12 > Console).
Run:
const ws = new WebSocket("ws://localhost:8081");
ws.onmessage = (e) => console.log("Received:", e.data);

//

What This Provides
✅ Minimal PHP backend (API & WebSockets)
✅ Dockerized for easy deployment
✅ Easily expandable for future features

